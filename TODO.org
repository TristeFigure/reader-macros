* TODO [[http://briancarper.net/blog/449/][Example]] from Brian Carper
  https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L82

  #+BEGIN_SRC clojure :tangle macros.clj :shebang #!/usr/bin/env clj
    (use 'add-classpath.core)
    (add-classpath "lib/*")
    (add-classpath "lib/dev/*")
    (use 'debug.core)
    (use 'clojure.test)
    
    (defn dispatch-reader-macro [ch fun]
      (let [dm (.get (doto (.getDeclaredField clojure.lang.LispReader "dispatchMacros")
                       (.setAccessible true))
                     nil)]
        (aset dm (int ch) fun)))
    
    (defn reader-macro [ch fun]
      (let [dm (.get (doto (.getDeclaredField clojure.lang.LispReader "macros")
                       (.setAccessible true))
                     nil)]
        (aset dm (int ch) fun)))
    
    (defn uppercase-string [rdr letter-u]
      (let [c (.read rdr)]
        (if (= c (int \"))
          (.toUpperCase (.invoke
                         (clojure.lang.LispReader$StringReader.)
                         rdr
                         c))
          (throw (Exception. (str "Reader barfed on " (char c)))))))
    
    (dispatch-reader-macro \U uppercase-string)
    (reader-macro \U uppercase-string)
    
    (is (= #U"Foo bar BAZ" "FOO BAR BAZ")
        (= U"Foo bar BAZ" "FOO BAR BAZ"))    
  #+END_SRC
* TODO API
  According to [[http://www.bookshelf.jp/texi/onlisp/onlisp_18.html][this]], we have =set-macro-character=,
  =set-dispatch-macro-character=, etc.:

  - [[http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ma.htm#set-macro-character][(set-macro-character char new-function)]]
  - [[http://www.lispworks.com/documentation/HyperSpec/Body/f_set_ma.htm#get-macro-character][(get-macro-character char)]]
  - [[http://www.lispworks.com/documentation/HyperSpec/Body/f_set__1.htm#set-dispatch-macro-character][(set-dispatch-macro-character disp-char sub-char new-function)]]
  - [[http://www.lispworks.com/documentation/HyperSpec/Body/f_set__1.htm#get-dispatch-macro-character][(get-dispatch-macro-character char)]]
  - [[http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_dis.htm#make-dispatch-macro-character][(make-dispatch-macro-character char)]]
  - [[http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_del.htm#read-delimited-list][(read-delimited-list char &optional input-stream recursive-p)]]

  where =new-function= has the signatures =(lambda (stream char)
  . . .)= and =(lambda (stream disp-char sub-char))=,
  respectively. (So, roughly on analogy with Clojure's read-table.)

  =set-macro-character= also has a notion of =non-terminating?=;
  =read-delimited-list= help find the end of a list with funny
  characters.

  (Hey, what do you know? Hickey implemented [[https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L1098][readDelimitedList]]; it
  requires a =java.io.PushbackReader=, though.)

  Like [[https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L100][this]], maybe =make-dispatch-macro-character= has the effect:

  #+BEGIN_SRC java
    macros['#'] = new DispatchReader();
  #+END_SRC

  Do we want to allow an optional read-table? Hmm; what's the point?
  It's [[https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L58][static]] in =LispReader=.

  E.g. [[https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L445][StringReader]] has the signature:

  #+BEGIN_SRC java
    public static class StringReader extends AFn{
        public Object invoke(Object reader, Object doublequote) {
            StringBuilder sb = new StringBuilder();
            Reader r = (Reader) reader;
            // . . .
            return stringBuilder.toString();
        }
    }
  #+END_SRC
* TODO Convenience readers
  See e.g. [[https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java#L84][string-reader]]:

  #+BEGIN_SRC clojure
    ;;; This doesn't work (we need an instance to get the method).
    (def string-reader LispReader$StringReader/invoke)
    
    ;;; This does, but it's ugly; and it's difficult to invoke.
    (get (:declaredMethods (bean LispReader$StringReader)) 0)
    
    ;;; Maybe this?
    (let [string-reader (new LispReader$StringReader)]
      (defn (read-string reader char)
        (.invoke string-reader reader char)))
    
  #+END_SRC
* TODO Implementation
  #+BEGIN_SRC clojure :tangle reader-macros.clj :shebang #!/usr/bin/env clj
    (use 'add-classpath.core)
    (add-classpath "lib/*" "lib/dev/*") 
    (use 'debug.core)
    (use 'clojure.test)
    (use 'lambda.core)
    
    (import '(clojure.lang LispReader
                           LispReader$StringReader
                           LispReader$CommentReader
                           LispReader$WrappingReader
                           LispReader$MetaReader
                           LispReader$SyntaxQuoteReader
                           LispReader$UnquoteReader
                           LispReader$ListReader
                           LispReader$UnmatchedDelimiterReader
                           LispReader$VectorReader
                           LispReader$MapReader
                           LispReader$CharacterReader
                           LispReader$ArgReader
                           LispReader$DispatchReader
                           LispReader$MetaReader
                           LispReader$VarReader
                           LispReader$RegexReader
                           LispReader$FnReader
                           LispReader$SetReader
                           LispReader$EvalReader
                           LispReader$CommentReader
                           LispReader$UnreadableReader
                           LispReader$DiscardReader
                           ))
    
    
    
    (let [macros (.getDeclaredField LispReader "macros")]
      (.setAccessible macros true)
      (deλ set-macro-character [character read]
        (aset macros (int character) read)))
    
  #+END_SRC
* TODO Define readers programmatically
  If we do this, funny enough, we don't actually have a guaranteed
  API; that's bad, isn't it?

  #+BEGIN_SRC clojure :tangle readers.clj :shebang #!/usr/bin/env clj
    (use 'add-classpath.core)
    (add-classpath "lib/*" "lib/dev/*")
    
    (use 'debug.core)
    (use 'lambda.core)
    (use 'clojure.string)
    
    (import 'clojure.lang.LispReader)
    (import 'java.util.regex.Pattern)
    
    ;;; re-seq exists.
    (def tokenize
      (λ [string regex]
        (let [matcher (re-matcher regex string)]
          (loop [tokens '()]
            (if (.find matcher)
              (recur (cons (re-groups matcher) tokens))
              tokens)))))
    
    (def class->reader
      (λ [class]
        (let [predicates (drop-last (re-seq #"[A-Z][a-z]+" class))]
          (format "read-%s" (join "-" predicates)))))
    
    (debug
     (map class->reader
          (map #(re-matches #"[A-Z][^A-Z]+" %)
               (filter #(re-find #"Reader$" %)
                       (map #(.getSimpleName %)
                            (into '()
                                  (:declaredClasses (bean LispReader))))))))
    
  #+END_SRC

  From [[https://github.com/richhickey/clojure-contrib/blob/a1c66df5287776b4397cf3929a5f498fbb34ea32/src/main/clojure/clojure/contrib/str_utils2.clj#L222][here]]:

  #+BEGIN_SRC clojure
    (defn partition
      "Splits the string into a lazy sequence of substrings, alternating
      between substrings that match the patthern and the substrings
      between the matches.  The sequence always starts with the substring
      before the first match, or an empty string if the beginning of the
      string matches.
    
      For example: (partition \"abc123def\" #\"[a-z]+\")
      returns: (\"\" \"abc\" \"123\" \"def\")"
      [#^String s #^Pattern re]
      (let [m (re-matcher re s)]
        ((fn step [prevend]
           (lazy-seq
            (if (.find m)
              (cons (.subSequence s prevend (.start m))
                    (cons (re-groups m)
                          (step (+ (.start m) (count (.group m))))))
              (when (< prevend (.length s))
                (list (.subSequence s prevend (.length s)))))))
         0)))
  #+END_SRC
